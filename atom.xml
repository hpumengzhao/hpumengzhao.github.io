<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng Space</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-11-18T02:21:23.669Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Codancer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LC891</title>
    <link href="http://yoursite.com/2022/11/18/LC891/"/>
    <id>http://yoursite.com/2022/11/18/LC891/</id>
    <published>2022-11-18T02:11:14.061Z</published>
    <updated>2022-11-18T02:21:23.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="891-子序列宽度之和"><a href="#891-子序列宽度之和" class="headerlink" title="891. 子序列宽度之和"></a>891. 子序列宽度之和</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p><p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>由于是子序列，因此和顺序无关，排序</p></li><li><p>假设$nums[i]$是最大值，那么最小值只能是$nums[j] (j &lt; i)$</p></li><li><p>枚举最大值，则最大值产生的贡献为：</p><script type="math/tex; mode=display">\sum_{i = 0}^{n - 1}\sum_{j = 0}^{i - 1}(nums[i]-nums[j]) * (2 ^ {i- j - 1})</script></li><li><p>拆分可得：</p><script type="math/tex; mode=display">\sum_{i = 0} ^ {n}2 ^ {i} (nums[i] * \sum_{j = 0}^{i - 1}(2^{-j-1}) - \sum_{j = 0}^{i - 1}(nums[j] * 2 ^{-j-1}))</script><p>使用两个前缀和维护即可</p></li><li><p>时间复杂度$O(nlog(n))$</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumSubseqWidths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =  (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;long long&gt; pre1(n), pre2(n);</span><br><span class="line">        pre1[<span class="number">0</span>] = qpow(qpow(<span class="number">2</span>, <span class="number">1</span>), mod - <span class="number">2</span>);</span><br><span class="line">        pre2[<span class="number">0</span>] = nums[<span class="number">0</span>] * pre1[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            pre1[j] = pre1[j - <span class="number">1</span>] + qpow(qpow(<span class="number">2</span>, j + <span class="number">1</span>), mod - <span class="number">2</span>);</span><br><span class="line">            pre1[j] %= mod;</span><br><span class="line">            pre2[j] = pre2[j - <span class="number">1</span>] + nums[j] * qpow(qpow(<span class="number">2</span>, j + <span class="number">1</span>), mod - <span class="number">2</span>) % mod;</span><br><span class="line">            pre2[j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t1 = qpow(<span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t2 = nums[i] * pre1[i - <span class="number">1</span>];</span><br><span class="line">            t2 %= mod;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t3 = pre2[i - <span class="number">1</span>];</span><br><span class="line">            t3 %= mod;</span><br><span class="line">            ans += (t1 * (t2 - t3 + mod) % mod) % mod;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;891-子序列宽度之和&quot;&gt;&lt;a href=&quot;#891-子序列宽度之和&quot; class=&quot;headerlink&quot; title=&quot;891. 子序列宽度之和&quot;&gt;&lt;/a&gt;891. 子序列宽度之和&lt;/h1&gt;&lt;h2 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>LC805. 数组的均值分割</title>
    <link href="http://yoursite.com/2022/11/14/LC805/"/>
    <id>http://yoursite.com/2022/11/14/LC805/</id>
    <published>2022-11-14T07:35:07.038Z</published>
    <updated>2022-11-14T07:46:59.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="805-数组的均值分割"><a href="#805-数组的均值分割" class="headerlink" title="805. 数组的均值分割"></a>805. 数组的均值分割</h1><a id="more"></a><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定你一个整数数组 <code>nums</code></p><p>我们要将 <code>nums</code> 数组中的每个元素移动到 <code>A</code> 数组 或者 <code>B</code> 数组中，使得 <code>A</code> 数组和 <code>B</code> 数组不为空，并且 <code>average(A) == average(B)</code> 。</p><p>如果可以完成则返回<code>true</code> ， 否则返回 <code>false</code> 。</p><p><strong>注意：</strong>对于数组 <code>arr</code> , <code>average(arr)</code> 是 <code>arr</code> 的所有元素的和除以 <code>arr</code> 长度。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><ul><li>$1 \leq n \leq 30$</li><li>$0 \leq nums[i] \leq 10^4$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>由于$1 \leq n \leq 30$, 考虑折半搜索。</p></li><li><p>分别对左侧数组和右侧数组进行二进制枚举，假设左侧选择了 $lc$ 个数字，和为 $ls$, 右侧选择了 $rc$ 个数字，和为$rs$，假设数组和为 $S$, 若要满足平均值相等，则有:</p><script type="math/tex; mode=display">\frac{S - ls - rs}{n - lc - nc} = \frac{ls + rs}{lc + nc}</script></li></ul><ul><li><p>化简可得：$S\times lc - n \times ls$ = $-(S \times rc - n \times rs)$ </p></li><li><p>预处理 $S\times lc - n \times ls$ 的值</p></li><li>注意边界情况，左侧和右侧不能同时全选</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitArraySameAverage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L, R;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) s += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            L.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            R.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ln = (<span class="keyword">int</span>)L.size();</span><br><span class="line">        <span class="keyword">int</span> rn = (<span class="keyword">int</span>)R.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; A, B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; ln); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ss = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ln; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    ss += L[j];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            A.push_back(&#123;ss, cnt&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; rn); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ss = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rn; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    ss += R[j];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            B.push_back(&#123;ss, cnt&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rec, allL, noL;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: A)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = v.first;</span><br><span class="line">            <span class="keyword">int</span> y1 = v.second;</span><br><span class="line">            <span class="keyword">if</span>(y1 == <span class="number">0</span>)&#123;</span><br><span class="line">                 noL[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y1 == ln)&#123;</span><br><span class="line">                allL[s * y1 - n * x1] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec[s * y1 - n * x1] = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: B)&#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = v.first;</span><br><span class="line">            <span class="keyword">int</span> y2 = v.second;</span><br><span class="line">            <span class="keyword">if</span>(y2 != rn)&#123;</span><br><span class="line">                <span class="keyword">if</span>(allL[-(s * y2 - n * x2)] || rec[-(s * y2 - n * x2)]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(noL[-(s * y2 - n * x2)] || rec[-(s * y2 - n * x2)]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;805-数组的均值分割&quot;&gt;&lt;a href=&quot;#805-数组的均值分割&quot; class=&quot;headerlink&quot; title=&quot;805. 数组的均值分割&quot;&gt;&lt;/a&gt;805. 数组的均值分割&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣周赛318题解</title>
    <link href="http://yoursite.com/2022/11/06/LC318/"/>
    <id>http://yoursite.com/2022/11/06/LC318/</id>
    <published>2022-11-06T07:31:28.078Z</published>
    <updated>2022-11-06T08:24:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣周赛318题解"><a href="#力扣周赛318题解" class="headerlink" title="力扣周赛318题解"></a>力扣周赛318题解</h1><a id="more"></a><h2 id="对数组执行操作"><a href="#对数组执行操作" class="headerlink" title="对数组执行操作"></a><a href="https://leetcode.cn/problems/apply-operations-to-an-array/" target="_blank" rel="noopener">对数组执行操作</a></h2><p>题意：略</p><p>题解：</p><ul><li>直接按照题意模拟即可。</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">applyOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[i] *= <span class="number">2</span>;</span><br><span class="line">                nums[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v) ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span>) ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="长度为-K-子数组中的最大和"><a href="#长度为-K-子数组中的最大和" class="headerlink" title="长度为 K 子数组中的最大和"></a><a href="https://leetcode.cn/contest/weekly-contest-318/problems/maximum-sum-of-distinct-subarrays-with-length-k/" target="_blank" rel="noopener">长度为 K 子数组中的最大和</a></h2><p>简要题意：</p><p>对于一个长度为$n$的数组，求和最大的长度为$k$的不存在重复元素的子数组的和。</p><p>题解：</p><ul><li>使用set和map维护长度为$k$的窗口</li><li>前缀和</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maximumSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; st;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) st.insert(nums[i]), mps[nums[i]]++;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)st.size() == k)&#123;</span><br><span class="line">            ans = max(ans, pre[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            mps[nums[i - k - <span class="number">1</span>]]--;</span><br><span class="line">            <span class="keyword">if</span>(mps[nums[i - k - <span class="number">1</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = st.find(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">                st.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">            st.insert(nums[i - <span class="number">1</span>]);</span><br><span class="line">            mps[nums[i - <span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)st.size() == k)&#123;</span><br><span class="line">                ans = max(ans, pre[i] - pre[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="雇佣-K-位工人的总代价"><a href="#雇佣-K-位工人的总代价" class="headerlink" title="雇佣 K 位工人的总代价"></a><a href="https://leetcode.cn/contest/weekly-contest-318/problems/total-cost-to-hire-k-workers/" target="_blank" rel="noopener">雇佣 K 位工人的总代价</a></h2><p>简要题意：</p><p>对于一个长度为$n$的序列，每次在前$m$个元素和后$m$个元素中选择最小的删除，求$k$次的和。</p><p>题解：</p><ul><li>使用两个优先队列维护前$m$个元素和后$m$个元素</li><li>双指针来拓展这两个优先队列</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a,node b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.val == b.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> a.id &gt; b.id;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">totalCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)cost.size();</span><br><span class="line">        <span class="keyword">int</span> L = m - <span class="number">1</span>;<span class="comment">//&lt;=L</span></span><br><span class="line">        <span class="keyword">int</span> R = n - m;<span class="comment">//&gt;=R</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; tot;</span><br><span class="line">        priority_queue&lt;node&gt; A, B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++)&#123;</span><br><span class="line">            node p;</span><br><span class="line">            p.id = i;</span><br><span class="line">            p.val = cost[i];</span><br><span class="line">             A.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i &lt; n; i++)&#123;</span><br><span class="line">            node p;</span><br><span class="line">            p.id = i;</span><br><span class="line">            p.val = cost[i];</span><br><span class="line">            B.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> steps = <span class="number">1</span>; steps &lt;= k; steps++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.empty())&#123;</span><br><span class="line">                ans += B.top().val;</span><br><span class="line">                vis[B.top().id] = <span class="number">1</span>;</span><br><span class="line">                B.pop();</span><br><span class="line">                R--;</span><br><span class="line">                <span class="keyword">while</span>(R &gt;= <span class="number">0</span> &amp;&amp; vis[R]) R--;</span><br><span class="line">                <span class="keyword">if</span>(R &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    B.push(&#123;R, cost[R]&#125;); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(B.empty())&#123;</span><br><span class="line">                ans += A.top().val;</span><br><span class="line">                vis[A.top().id] = <span class="number">1</span>;</span><br><span class="line">                A.pop();</span><br><span class="line">                L++;</span><br><span class="line">                <span class="keyword">while</span>(L &lt; n &amp;&amp; vis[L]) L++;</span><br><span class="line">                <span class="keyword">if</span>(L &lt; n)&#123;</span><br><span class="line">                    A.push(&#123;L, cost[L]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> l = A.top();</span><br><span class="line">            <span class="keyword">auto</span> r = B.top();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; steps &lt;&lt; "Lval: " &lt;&lt; l.val &lt;&lt; "Lid " &lt;&lt; l.id &lt;&lt; "Rval " &lt;&lt; r.val &lt;&lt; "Rid " &lt;&lt; r.id &lt;&lt;  endl;</span></span><br><span class="line">            <span class="keyword">if</span>(l.val == r.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l.id &lt; r.id)&#123;</span><br><span class="line">                    vis[A.top().id] = <span class="number">1</span>;</span><br><span class="line">                    A.pop();</span><br><span class="line">                    ans += l.val;</span><br><span class="line">                    L++;</span><br><span class="line">                    <span class="keyword">while</span>(L &lt; n &amp;&amp; vis[L]) L++;</span><br><span class="line">                    <span class="keyword">if</span>(L &lt; n)&#123;</span><br><span class="line">                        A.push(&#123;L, cost[L]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l.id &gt; r.id)&#123;</span><br><span class="line">                    vis[B.top().id] = <span class="number">1</span>;</span><br><span class="line">                    B.pop();</span><br><span class="line">                    ans += r.val;</span><br><span class="line">                    R--;</span><br><span class="line">                    <span class="keyword">while</span>(R &gt;= <span class="number">0</span> &amp;&amp; vis[R]) R--;</span><br><span class="line">                    <span class="keyword">if</span>(R &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        B.push(&#123;R, cost[R]&#125;); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l.id == r.id)&#123;</span><br><span class="line">                    vis[A.top().id] = <span class="number">1</span>;</span><br><span class="line">                    A.pop();B.pop();</span><br><span class="line">                    ans += l.val;</span><br><span class="line">                    L++;</span><br><span class="line">                    <span class="keyword">while</span>(L &lt; n &amp;&amp; vis[L]) L++;</span><br><span class="line">                    <span class="keyword">if</span>(L &lt; n)&#123;</span><br><span class="line">                        A.push(&#123;L, cost[L]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    R--;</span><br><span class="line">                    <span class="keyword">while</span>(R &gt;= <span class="number">0</span> &amp;&amp; vis[R]) R--;</span><br><span class="line">                    <span class="keyword">if</span>(R &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        B.push(&#123;R, cost[R]&#125;); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l.val &lt; r.val)&#123;</span><br><span class="line">                vis[A.top().id] = <span class="number">1</span>;</span><br><span class="line">                A.pop();</span><br><span class="line">                ans += l.val;</span><br><span class="line">                L++;</span><br><span class="line">                <span class="keyword">while</span>(L &lt; n &amp;&amp; vis[L]) L++;</span><br><span class="line">                <span class="keyword">if</span>(L &lt; n)&#123;</span><br><span class="line">                    A.push(&#123;L, cost[L]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vis[B.top().id] = <span class="number">1</span>;</span><br><span class="line">                B.pop();</span><br><span class="line">                ans += r.val;</span><br><span class="line">                R--;</span><br><span class="line">                <span class="keyword">while</span>(R &gt;= <span class="number">0</span> &amp;&amp; vis[R]) R--;</span><br><span class="line">                <span class="keyword">if</span>(R &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    B.push(&#123;R, cost[R]&#125;); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小移动总距离"><a href="#最小移动总距离" class="headerlink" title="最小移动总距离"></a><a href="https://leetcode.cn/problems/minimum-total-distance-traveled/" target="_blank" rel="noopener">最小移动总距离</a></h2><p>简要题意：</p><p>$n$个坏掉的机器人， 第$i$个机器人的位置在$p_{i}$，有$m$个修理厂，第$i$个的修理厂位置在$x_{i}$，最多能修理$y_{i}$个机器人。机器人从$x$移动到$y$需要的距离是$|x - y|$。</p><p>求修复好所有机器人最小的移动距离。</p><p>题解：</p><ul><li><p>将机器人和修理厂按位置排序，一个修理厂一定是修复连续的一段机器人</p></li><li><p>动态规划，考虑$dp[i][j]$表示前$i$个修理厂修复了前$j$个机器人最小的移动距离，则有</p><script type="math/tex; mode=display">dp[i][j + k] = min(dp[i - 1][j + k], \min_{k = 1}^{y_{i}}\{dp[i - 1][j] + \sum_{k=j+1}^{min(n, j + k)}cost[i][k]\}</script></li></ul><p>其中$cost[i][j]$表示第$j$个机器人移动到第$i$个修理厂需要的距离。</p><ul><li>时间复杂度$O(n ^ 3)$</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cost[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minimumTotalDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; robot, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; factory)</span> </span>&#123;</span><br><span class="line">        sort(robot.begin(), robot.end());</span><br><span class="line">        sort(factory.begin(), factory.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>)robot.size();</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)factory.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                cost[i][j] = <span class="built_in">abs</span>(robot[j - <span class="number">1</span>] - factory[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) dp[i][j] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= factory[i - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; j + k &lt;= m; k++)&#123;</span><br><span class="line">                    now += cost[i][j + k];</span><br><span class="line">                    dp[i][j + k] = min(dp[i][j + k], dp[i - <span class="number">1</span>][j] + now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p><a href="https://imgse.com/i/xXz04x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2022/11/06/xXz04x.jpg" alt="xXz04x.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;力扣周赛318题解&quot;&gt;&lt;a href=&quot;#力扣周赛318题解&quot; class=&quot;headerlink&quot; title=&quot;力扣周赛318题解&quot;&gt;&lt;/a&gt;力扣周赛318题解&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>使数组按非递减顺序排列</title>
    <link href="http://yoursite.com/2022/05/29/LC6060/"/>
    <id>http://yoursite.com/2022/05/29/LC6060/</id>
    <published>2022-05-29T06:56:48.157Z</published>
    <updated>2022-05-29T06:44:37.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-6080-使数组按非递减顺序排列"><a href="#Leetcode-6080-使数组按非递减顺序排列" class="headerlink" title="Leetcode 6080.  使数组按非递减顺序排列"></a>Leetcode 6080.  使数组按非递减顺序排列</h1><a id="more"></a><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] &gt; nums[i] 的 nums[i] ，其中 0 &lt; i &lt; nums.length 。</p><p>重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p>对于$nums[i]$，如果存在$j$满足$j &lt; i$ 且$nums[j] &lt; nums[i]$，则$nums[i]$则一定会被删除</p></li><li><p>对于$nums[i]$，找到左边距离其最近的$nums[j]$，则在删除$nums[i]$之前，一定是先删除了$[nums[j + 1],…, nums[i - 1]]$之后再删除的$nums[i]$</p></li><li><p>令$dp[i]$表示删除$nums[i]$的轮数，则有:</p><script type="math/tex; mode=display">dp[i] = \max_{k = j + 1}^{i - 1}dp[k]</script></li><li><p>因此我们可以用单调栈维护一个单调递减的栈，对于每个$i$求得对应的$j$，并且在维护单调栈的过程中进行动态规划，时间复杂度$O(n)$。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalSteps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!sta.empty() &amp;&amp; nums[sta.top()] &lt;= nums[i])&#123;</span><br><span class="line">                cur = max(cur, dp[sta.top()]);</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!sta.empty())&#123;<span class="comment">//说明存在nums[j] &lt; nums[i]</span></span><br><span class="line">                dp[i] = cur + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxx = max(maxx, dp[i]);</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-6080-使数组按非递减顺序排列&quot;&gt;&lt;a href=&quot;#Leetcode-6080-使数组按非递减顺序排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 6080.  使数组按非递减顺序排列&quot;&gt;&lt;/a&gt;Leetcode 6080.  使数组按非递减顺序排列&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="力扣周赛" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>GCC学习笔记</title>
    <link href="http://yoursite.com/2022/05/09/GCC/"/>
    <id>http://yoursite.com/2022/05/09/GCC/</id>
    <published>2022-05-09T02:15:42.868Z</published>
    <updated>2022-05-09T07:21:25.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCC学习笔记"><a href="#GCC学习笔记" class="headerlink" title="GCC学习笔记"></a>GCC学习笔记</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GCC是GNU Compiler Collection的缩写，它是一套编程语言编译器的集合，在最初的时候只能编译C语言，之后扩展便可以处理C++， Fortran，Objective-C， JAVA和GO等语言。</p><p>本文主要介绍GCC编译C项目的过程。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>对于一个源代码程序.c，要想其被计算机执行，需要大概如下几步：</p><ul><li>预处理过程：替换头文件、宏定义等，其本质是一个文本替换过程，得到的文件以.i结尾。</li><li>编译：将文件编译为汇编代码，文件以.s结尾。</li><li>汇编：使用汇编器将汇编代码转为二进制文件.o。</li><li>链接：由于.o文件调用了一些动态库或者静态库，需要将这些库代码和.o文件打包（动态库不需要把代码打包）才能得到最终的可运行的二进制文件。</li></ul><h2 id="GCC编译参数"><a href="#GCC编译参数" class="headerlink" title="GCC编译参数"></a>GCC编译参数</h2><div class="table-container"><table><thead><tr><th>编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>预处理源文件，如(gcc -E main.c -o main.i)</td></tr><tr><td>-S</td><td>编译源文件，生成汇编代码，但是不进行汇编(gcc -S main.c -o main.s)</td></tr><tr><td>-c</td><td>编译、汇编源文件，但不链接</td></tr><tr><td>-o [file1] [file2]/ [file2] -o [file1]</td><td>将file2编译成可执行文件file1</td></tr><tr><td>-I dir</td><td>指定include文件的目录</td></tr><tr><td>-g</td><td>生成调试信息</td></tr><tr><td>-D</td><td>编译程序时指定一个宏， 如-D DEBUG</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-Wall</td><td>生成所有的警告信息</td></tr><tr><td>-O0,-O1,O2,O3</td><td>编译优化，O0无优化，O1缺省值，O3优化级别最高。</td></tr><tr><td>-l</td><td>程序编译的时候指定使用的库，如-lm是链接math库</td></tr><tr><td>-fpic/-fPIC</td><td>生成和位置无关的代码,用来制作动态库</td></tr><tr><td>-shared</td><td>生成共享目标文件，用来生成动态库</td></tr><tr><td>-std</td><td>指定编译版本，如-std=c99,-std=c++11…</td></tr></tbody></table></div><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>对于若干.c程序，我们首先使用编译它们生成各自的.o文件，然后使用ar工具，执行ar rcs libxxx.a(xxx是库名) *.o将他们打包为静态库。再linux下静态库是以.a文件结尾。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── mod.c</span><br><span class="line">    ├── mul.c</span><br><span class="line">    └── sub.c</span><br></pre></td></tr></table></figure><p>现在我们有这样一个简单的项目，head.h声明了五个函数，这五个函数分别由src中的代码实现，在main中我们调用了这几个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sub(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -I .&#x2F;include&#x2F;</span><br></pre></td></tr></table></figure><p>则会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ld: &#x2F;tmp&#x2F;ccRyDshG.o: in function &#96;main&#39;:</span><br><span class="line">main.c:(.text+0x13): undefined reference to &#96;add&#39;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ld: main.c:(.text+0x35): undefined reference to &#96;sub&#39;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>其实就是因为我们虽然使用了head头文件，但是生成的二进制文件找不到对应的函数实现的二进制文件。因此我们需要把这些函数实现打包成静态库。</p><p>进入src目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c *.c -I ..&#x2F;include&#x2F;</span><br></pre></td></tr></table></figure><p>这样我们就对每个c文件生成了对应的二进制文件。</p><p>继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libcalc.a *.o</span><br></pre></td></tr></table></figure><p>我们就可以把*.o文件打包为libcalc.a静态库文件，库名字为calc，将该文件拷贝到lib目录下。</p><p>返回上级目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -I .&#x2F;include&#x2F; -lcalc -L .&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure><p>运行main即可得到正确结果。</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>显然，静态库存在一些缺点，首先是浪费空间，对于每个可执行文件都需要将库打包，不可共用，其次是如果更新了静态库，则还需要重新链接。</p><p>动态库则是为解决这两个问题而产生的。动态链接是在程序运行时，如果需要某个库，再将其链接到可执行程序上。Linux中，动态库的文件后缀为.so。</p><p>接下来展示如何制作动态库并链接。</p><p>同静态库样例，还是一样的程序，只不过在src下，我们执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c *.c -fpic -I ..&#x2F;include&#x2F;</span><br></pre></td></tr></table></figure><p>用来生成和位置无关的代码（指运行和放置地址无关的代码）</p><p>然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared *.o -o libcalcd.so</span><br></pre></td></tr></table></figure><p>将*.o打包成calcd动态库。</p><p>最后编译main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -I .&#x2F;include&#x2F; -l calcd -L .&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure><p>如果直接运行会报错，这是因为我们需要把动态库的路径保存到环境变量。</p><p>在etc的bashrc文件最后一行导入（LD_LIBRARY_PATH是linux下的一个环境变量）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH: libpath</span><br></pre></td></tr></table></figure><p>使用ldd命令查看动态库依赖情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007fffc48d5000)</span><br><span class="line">libcalcd.so &#x3D;&gt; &#x2F;mnt&#x2F;d&#x2F;cpplearning&#x2F;2.0&#x2F;gcc&#x2F;dynamic_lib&#x2F;lib&#x2F;libcalcd.so (0x00007f554b830000)</span><br><span class="line">libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f554b630000)</span><br><span class="line">&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f554b84b000)</span><br></pre></td></tr></table></figure><p>运行main即可得到正确输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GCC学习笔记&quot;&gt;&lt;a href=&quot;#GCC学习笔记&quot; class=&quot;headerlink&quot; title=&quot;GCC学习笔记&quot;&gt;&lt;/a&gt;GCC学习笔记&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记-深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2022/05/06/cpp-2/"/>
    <id>http://yoursite.com/2022/05/06/cpp-2/</id>
    <published>2022-05-06T11:20:23.241Z</published>
    <updated>2022-05-06T12:08:50.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-笔记-深拷贝与浅拷贝"><a href="#C-笔记-深拷贝与浅拷贝" class="headerlink" title="C++笔记-深拷贝与浅拷贝"></a>C++笔记-深拷贝与浅拷贝</h1><a id="more"></a><p>对于拷贝构造函数，需要注意的一点是要使用深拷贝，不然有可能会出现double free错误。</p><p>首先需要清楚的一点是：浅拷贝只复制某个对象的指针，但是并不会复制该对象的内容，只是新建了一个指向该内存地址的指针。而深拷贝则是将整个对象复制，双方不会共享内存。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Foo(<span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo(Foo &amp;other)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = other.n;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = other.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;p[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Foo()&#123;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Foo obj1&#123;<span class="number">3</span>&#125;;</span><br><span class="line">Foo obj2 = obj1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述程序，如果我们直接运行，则会出现double free。首先我们新建了一个对象obj1，obj1初始化的时候会创建一个长度为3的动态数组p。</p><p>我们使用拷贝构造函数创造对象obj2，这个时候obj2中的p并没有进行深拷贝，而是接受了obj1中数组p的起始地址。</p><p>当程序执行结束，obj1首先被析构函数销毁，此时p区域已经被释放，而obj2再次被销毁时就会重复释放已经空的地址，从而导致double free。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Foo(<span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo(Foo &amp;other)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = other.n;</span><br><span class="line"><span class="comment">// this-&gt;p = other.p;</span></span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">int</span>[other.n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; other.n; i++)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p[i] = other.p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;p[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Foo()&#123;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Foo obj1&#123;<span class="number">2</span>&#125;;</span><br><span class="line">Foo obj2 = obj1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝数组p时使用深拷贝，申请完内存再将数组内的所有元素复制进来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-笔记-深拷贝与浅拷贝&quot;&gt;&lt;a href=&quot;#C-笔记-深拷贝与浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;C++笔记-深拷贝与浅拷贝&quot;&gt;&lt;/a&gt;C++笔记-深拷贝与浅拷贝&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记-Variadic Templates</title>
    <link href="http://yoursite.com/2022/04/24/cpp-1/"/>
    <id>http://yoursite.com/2022/04/24/cpp-1/</id>
    <published>2022-04-24T08:57:24.173Z</published>
    <updated>2022-05-06T11:20:09.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-笔记-Variadic-Templates"><a href="#C-笔记-Variadic-Templates" class="headerlink" title="C++笔记-Variadic Templates"></a>C++笔记-Variadic Templates</h1><a id="more"></a><p>C++ 11引入了可变参数模板，使得用户可以实现传入未知数目且未知数据类型参数的函数。</p><h2 id="1-Demo"><a href="#1-Demo" class="headerlink" title="1. Demo"></a>1. Demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printxx</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printxx</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... Args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof package"</span> &lt;&lt; <span class="string">' '</span>&lt;&lt;<span class="keyword">sizeof</span>...(Args)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printxx(Args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">printxx(<span class="number">1.7</span>, <span class="string">"bad"</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printxx函数包含两个参数firstArg和 Args，Args是一个包(package)，可以包含任意数目任意类型的参数，因此我们需要使用递归的方法来使用可变参数模板。</p><p>我们可以使用sizeof…(Args)来获取当前包的大小。当我们调用printxx函数的时候，1.7作为firstArg被输出，Args包含其余三个元素，然后递归调用printxxx。由于递归终点是参数为空，而printxx需要至少有一个参数，因此，我们需要重新写一个不含参数的printxx函数。</p><h2 id="2-调用规则"><a href="#2-调用规则" class="headerlink" title="2. 调用规则"></a>2. 调用规则</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printxx</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printxx</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... Args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Call A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printxx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* firstArg, <span class="keyword">const</span> T&amp; secondArg, <span class="keyword">const</span> Types&amp;... Args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Call C"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printxx</span><span class="params">(<span class="keyword">const</span> Types&amp;... Args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Call B"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">printxx(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于该程序，输出结果为”Call C”，这是因为函数会调用特化最强的，而不是泛化最强的。也即对于所有满足条件的函数，会调用参数最细化的。</p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p>C++中的tuple， unordered容器就是用Variadic Template实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-笔记-Variadic-Templates&quot;&gt;&lt;a href=&quot;#C-笔记-Variadic-Templates&quot; class=&quot;headerlink&quot; title=&quot;C++笔记-Variadic Templates&quot;&gt;&lt;/a&gt;C++笔记-Variadic Templates&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>高等工程数学笔记-4</title>
    <link href="http://yoursite.com/2021/09/23/AM4/"/>
    <id>http://yoursite.com/2021/09/23/AM4/</id>
    <published>2021-09-23T05:12:42.602Z</published>
    <updated>2021-09-23T06:19:55.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter3-1-矩阵的标准型与特征值计算"><a href="#Chapter3-1-矩阵的标准型与特征值计算" class="headerlink" title="Chapter3-1: 矩阵的标准型与特征值计算"></a>Chapter3-1: 矩阵的标准型与特征值计算</h1><a id="more"></a><h2 id="Jordan标准型"><a href="#Jordan标准型" class="headerlink" title="Jordan标准型"></a>Jordan标准型</h2><p>形如：</p><script type="math/tex; mode=display">J_{i} = \left[ \begin{matrix} \lambda_{i} & 1 \\ & \lambda_{i} & 1 \\ & & ...  \\ & & &\lambda_{i}\\ \end{matrix} \right]_{r_{i} \times r_{i}}</script><p>的矩阵被称为$r_{i}$阶Jordan块。由若干个Jordan块构成的分块对角矩阵成为Jordan标准型：</p><script type="math/tex; mode=display">J = \left[ \begin{matrix} J_{1} \\ & J_{2} \\ & & J_{3} \\ &&&... \\&&&& J_{s}  \end{matrix} \right]</script><h2 id="Jordan定理"><a href="#Jordan定理" class="headerlink" title="Jordan定理"></a>Jordan定理</h2><p>设$A \in C^{n \times n}$，则$A$与一个Jordan标准型相似，即存在$P \in C_{n} ^{n \times n}$使得$P^{-1}AP=J$。且这个Jordan标准型除了其中的Jordan块的排列顺序外被$A$唯一决定。则称其为$A$的Jordan标准型，记为$J_{A}$。</p><h2 id="Jordan标准型及相似变换矩阵的求解"><a href="#Jordan标准型及相似变换矩阵的求解" class="headerlink" title="Jordan标准型及相似变换矩阵的求解"></a>Jordan标准型及相似变换矩阵的求解</h2><p>设$a_{ij}(\lambda)(i=1,2,3…m;j=1,2,3…,n)$，为复数域上的多项式，则以$a_{ij}(\lambda)$为元素的 $m \times n$阶矩阵</p><script type="math/tex; mode=display">A(\lambda) = \left[ \begin{matrix}a_{11}(\lambda) & a_{12}(\lambda) & ... & a_{1n}(\lambda) \\ ...  \\ a_{m1}(\lambda) & a_{m2}(\lambda) & ... & a_{mn}(\lambda)\end{matrix} \right]</script><p>为$\lambda$矩阵或者多项式矩阵。</p><p>如果$\lambda$矩阵$A(\lambda)$存在一个$r(r \geq 1)$阶子式为非零多项式，而所有的$r+1$（如果存在）阶子式全为零多项式，则称$A(\lambda)$的秩为$r$，记作:</p><p>$\rank(A(\lambda))=r$或者$r_{A(\lambda)}=r$。零矩阵的秩为0。</p><p>如果$n$阶矩阵$A(\lambda)$的秩为$n$，则$A(\lambda)$满秩或非奇异，否则称$A(\lambda)$降秩或者奇异的。</p><h3 id="初等行变化-列变换"><a href="#初等行变化-列变换" class="headerlink" title="初等行变化/列变换"></a>初等行变化/列变换</h3><ul><li>交换两行(列)</li><li>用$k(k \neq 0)$数乘某行/列的所有元素</li><li>某行(列)的$\varphi(\lambda)$倍加到零一行(列)</li></ul><p>如果$\lambda$矩阵$A(\lambda)$经过有限次初等变换变成$\lambda$矩阵$B(\lambda)$，则称$A(\lambda)$与$B(\lambda)$矩阵等价，记作$A \simeq B$。</p><p>定理：</p><p>任意非零的$\lambda$矩阵$A(\lambda)=(a_{ij}(\lambda))_{m \times n}$等价于如下形式的矩阵：</p><script type="math/tex; mode=display">A(\lambda) \simeq S(\lambda)=\left( \begin{matrix} d_{1}(\lambda) \\ & d_{2}(\lambda) \\ & & ...\\ &&& d_{r}(\lambda) \\ & & &  & ... \\ & & & & & 0 \\ & & & & & & 0 \end{matrix} \right)</script><p>其中$r$为$A(\lambda)$的秩，$d_{i}(\lambda)$是首项系数为1的多项式，且$d_{i}(\lambda)|d_{i+1}(\lambda)(i=1,…,r-1)$。</p><p>$S(\lambda)$被称为$A(\lambda)$的<strong>Smith标准型</strong>，$d_{i}(\lambda)$成为$A(\lambda)$的不变因子。</p><p>例题：</p><p>求$\lambda$矩阵</p><script type="math/tex; mode=display">A(\lambda)=\left( \begin{matrix}1-\lambda & 2\lambda-1 & \lambda \\ \lambda & \lambda^2 & -\lambda \\1+\lambda^2 & \lambda^2+\lambda-1 & -\lambda^2 \end{matrix} \right )</script><p>的Smith标准型和不变因子：</p><p><img src="https://i.loli.net/2021/09/23/tekY6gIGUfwm8pF.png" alt="image.png" style="zoom: 50%;" /></p><p>因此所求的Smith标准型为：</p><script type="math/tex; mode=display">S(\lambda) = \left( \begin{matrix} 1 & 0 & 0 \\ 0 & \lambda & 0 \\ 0 & 0 & \lambda^3+\lambda \end{matrix} \right)</script><p>不变因子为：$d_{1}(\lambda)=1,d_{2}(\lambda)=\lambda,d_{3}(\lambda)=\lambda^3+\lambda$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chapter3-1-矩阵的标准型与特征值计算&quot;&gt;&lt;a href=&quot;#Chapter3-1-矩阵的标准型与特征值计算&quot; class=&quot;headerlink&quot; title=&quot;Chapter3-1: 矩阵的标准型与特征值计算&quot;&gt;&lt;/a&gt;Chapter3-1: 矩阵的标准型与特征值计算&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="高等工程数学笔记" scheme="http://yoursite.com/tags/%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>高等工程数学笔记-3</title>
    <link href="http://yoursite.com/2021/09/23/AM3/"/>
    <id>http://yoursite.com/2021/09/23/AM3/</id>
    <published>2021-09-23T04:58:57.403Z</published>
    <updated>2021-09-27T10:49:29.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter2-2-矩阵的条件数及应用"><a href="#Chapter2-2-矩阵的条件数及应用" class="headerlink" title="Chapter2-2:  矩阵的条件数及应用"></a>Chapter2-2:  矩阵的条件数及应用</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设$A \in C^{n \times n}_{n}$，$||.||$是$C^{n \times n}$上的一个矩阵范数，则矩阵$A$的的条件数定义为：</p><script type="math/tex; mode=display">cond(A)=||A|| \cdot ||A^{-1}||</script><p>若$cond(A)$较小（接近1），则$A$关于求解矩阵逆或求解线性方程组为良好的或好条件的，如果$cond(A)$比较大，则称$A$关于求解矩阵逆或求解线性方程组为病态的或坏条件的。</p><p>常用的条件数：</p><script type="math/tex; mode=display">cond_{\infty}(A) = ||A||_{\infty} ||A^{-1}||_{\infty}</script><script type="math/tex; mode=display">cond_{2}(A)=||A||_{2}||A^{-1}||_{2} = \sqrt{\frac{\lambda_{1}}{\lambda_{n}}}</script><p>其中$\lambda_{1},\lambda_{n}$分别为矩阵$A^HA$的最大和最小的特征值。</p><p>特别的，如果$A$是正规矩阵，则有：</p><script type="math/tex; mode=display">cond_{2}(A)=||A||_{2}||A^{-1}||_{2}=\frac{\max\{\lambda\}}{\min\{\lambda\}}</script><p>其中$\lambda$是$A$的特征值。</p><p>例题：</p><p>设$A =\left[  \begin{matrix}1 &amp; -2 &amp; 2 \\ -2 &amp; -2 &amp; 4  \\ 2 &amp; 4 &amp; -2 \end{matrix} \right]$，选取$C^{3 \times 3}$上的范数$||.||_{\alpha}$使得：</p><script type="math/tex; mode=display">k_{\alpha}(A) = ||A||_{\alpha}||A^{-1}||_{\alpha}</script><p>最小。</p><p>解析：</p><p>$A$ 是对称矩阵，因此有$\rho(A) =||A||_{2} \leq ||A||$</p><p>因此选择2范数能使$k_{\alpha}(A)$最小。</p><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>设$A \in C_{n}^{n \times n}, \delta A \in C^{n \times n}$，若对于$C^{n \times n}$上的某一范数矩阵$||.||$有$||A^{-1} \delta A|| &lt;1$，则有：</p><ul><li>$A+\delta A$可逆</li><li><p>$||(A+\delta A)^{-1}|| \leq \frac{||A^{-1}||}{1-||A^{-1} \delta A||}$</p></li><li><p>$\frac{||A^{-1}-(A+\delta A)^{-1}||}{||A^{-1}||} \leq \frac{||A^-1 \delta A||}{1-||A^{-1} \delta A||}$</p></li></ul><p>推论：</p><p>设$A \in C_{n}^{n \times n}, \delta A \in C^{n \times n}$,若对$C^{n \times n}$上某矩阵范数$||.||$有：$||A^{-1}||||\delta A|| &lt; 1$，则（相对误差）：</p><script type="math/tex; mode=display">\frac{||A^{-1}-(A+\delta A)^{-1}||}{||A^{-1}||} \leq \frac{cond(A)\frac{||\delta A||}{||A||}}{1-cond(A)\frac{||\delta A||}{||A||}}</script><p>定理*：</p><p>设$A \in C_{n}^{n \times n}, \delta A \in C^{n \times n},b, \delta b \in C^n$，如果对于$C^{n \times n}$上的某范数$||.||$有$||A^{-1}||||\delta A|| &lt; 1$,则有：</p><p>$Ax=b$的解和$(A+ \delta A) \hat{x} = (b+\delta b)$的解满足：</p><script type="math/tex; mode=display">\frac{||x-\hat{x}||_{\alpha}}{||x||_{\alpha}} \leq \frac{cond(A)}{1-cond(A)\frac{||\delta A||}{||A||}}(\frac{||\delta A||}{||A||}+\frac{||\delta b||_{\alpha}}{||b||_{\alpha}})</script><p>其中$||.||_{\alpha}$是$C^{n}$上与矩阵范数$||.||$相容的向量范数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chapter2-2-矩阵的条件数及应用&quot;&gt;&lt;a href=&quot;#Chapter2-2-矩阵的条件数及应用&quot; class=&quot;headerlink&quot; title=&quot;Chapter2-2:  矩阵的条件数及应用&quot;&gt;&lt;/a&gt;Chapter2-2:  矩阵的条件数及应用&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="高等工程数学笔记" scheme="http://yoursite.com/tags/%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>高等工程数学笔记-2</title>
    <link href="http://yoursite.com/2021/09/23/AM2/"/>
    <id>http://yoursite.com/2021/09/23/AM2/</id>
    <published>2021-09-23T04:58:41.052Z</published>
    <updated>2021-09-23T04:53:15.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter2-1：矩阵的谱半径及应用"><a href="#Chapter2-1：矩阵的谱半径及应用" class="headerlink" title="Chapter2-1：矩阵的谱半径及应用"></a>Chapter2-1：矩阵的谱半径及应用</h1><a id="more"></a><h2 id="谱半径"><a href="#谱半径" class="headerlink" title="谱半径"></a>谱半径</h2><p>设$A \in C^{n \times n}$，$\lambda_{1},\lambda_{2},…,\lambda_{n}$为$A$的$n$个特征值，则矩阵$A$的谱半径为：</p><script type="math/tex; mode=display">\rho(A)=\max\limits_{j}|\lambda_{j}|</script><p>注：谱半径只是矩阵上的一个函数，但并不是矩阵范数。</p><p>定理：$\rho(A) \leq ||A||$</p><p>证明：</p><p>设$\lambda$是矩阵$A$的特征值，则有：</p><script type="math/tex; mode=display">||\lambda x||=|\lambda|\cdot||x||=||Ax|| \leq ||A|| \cdot ||x||</script><p>因此有</p><script type="math/tex; mode=display">|\lambda|\leq ||A||</script><p>故：</p><script type="math/tex; mode=display">\rho(A) \leq ||A||</script><p>定理：设$A \in C^{n \times n}$，对任意的 $\varepsilon&gt;0$，存在矩阵范数$||.||_{m}$使得：</p><script type="math/tex; mode=display">||A||_{m} \leq \varepsilon+\rho(A)</script><p>例题：</p><ul><li><p>对于$A \in C^{n \times n}$，证明：$||A||_{2} \leq max\{||A||_{1},||A||_{\infty}\}$</p><p>证明：</p><p>$||A_{2}|| = \sqrt{\rho(A^HA)}\leq \sqrt{||A^HA||_{1}} \leq \sqrt{||A^H||_{1}\cdot ||A||_{1}} \leq \sqrt{||A||_{\infty}||A||_{1}} \leq max\{||A||_{1},||A||_{\infty}\}$</p></li><li><p>当$A$是正规矩阵时，$\rho(A)=||A||_{2}$</p><p>证明：</p><p>当$A$是正规矩阵时，则$A$可以被酉矩阵$U$对角化，也即：</p><p>$U^HAU=P$，其中$P$为对角阵。</p><p>则$A=UPU^H$，故$||A||_{2}= \sqrt{\rho(A^HA)} = \sqrt{\rho(U^HP^HPU)} = \sqrt{\rho(P^HP)} = \rho(A)$。</p></li></ul><h2 id="序列矩阵在级数中的应用"><a href="#序列矩阵在级数中的应用" class="headerlink" title="序列矩阵在级数中的应用"></a>序列矩阵在级数中的应用</h2><h3 id="收敛矩阵"><a href="#收敛矩阵" class="headerlink" title="收敛矩阵"></a>收敛矩阵</h3><p>对于矩阵$A \in C^{n \times n}$，如果$\lim\limits_{k \rightarrow \infty}A^{k}=0$，则$A$为收敛矩阵。</p><p>收敛矩阵的充要条件是$\rho(A) &lt;1 $。</p><h3 id="矩阵级数"><a href="#矩阵级数" class="headerlink" title="矩阵级数"></a>矩阵级数</h3><p>设$\{A^{k}\}_{k=1}^{\infty}$是$C^{n \times n}$上的矩阵序列，则无穷和式：</p><script type="math/tex; mode=display">\sum\limits_{k=1}^{\infty}A^{(k)}</script><p>称为矩阵级数。</p><p>设$A^(k)=(a_{i,j}^k) \in C^{n \times n },(k=1,2,…,)$如果$n^2$个数项级数</p><script type="math/tex; mode=display">\sum\limits_{k=1}^{\infty}a_{i,j}^{(k)},i,j=1,2,...,n</script><p>均绝对收敛，则矩阵级数</p><script type="math/tex; mode=display">\sum\limits_{k=1}^{\infty}A^{(k)}</script><p>绝对收敛。</p><h3 id="矩阵幂级数"><a href="#矩阵幂级数" class="headerlink" title="矩阵幂级数"></a>矩阵幂级数</h3><p>设$A \in C^{n \times n},a_{k} \in C(k=0,1,….)$，则称：</p><script type="math/tex; mode=display">\sum\limits_{k=0}^{\infty}a_{k}A^{k}</script><p>为矩阵$A$的幂级数。</p><h4 id="矩阵幂级数散敛性的判断："><a href="#矩阵幂级数散敛性的判断：" class="headerlink" title="矩阵幂级数散敛性的判断："></a>矩阵幂级数散敛性的判断：</h4><p>设复变量幂级数$\sum\limits_{k=1}^{\infty}a_{k}z^{k}$的收敛半径为$R$，$A \in C^ {n \times n}$则：</p><ul><li>$\rho(A)&lt;R$的时候：矩阵幂级数$\sum\limits_{k=0}^{\infty}a_{k}A^{k}$绝对收敛</li><li>$\rho(A)&gt;R$的时候：矩阵幂级数$\sum\limits_{k=0}^{\infty}a_{k}A^{k}$发散</li></ul><p>收敛半径的计算：</p><script type="math/tex; mode=display">R=\frac{1}{\lim\limits_{k \rightarrow\infty}|\frac{a_{k+1}}{a_{k}}|}</script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chapter2-1：矩阵的谱半径及应用&quot;&gt;&lt;a href=&quot;#Chapter2-1：矩阵的谱半径及应用&quot; class=&quot;headerlink&quot; title=&quot;Chapter2-1：矩阵的谱半径及应用&quot;&gt;&lt;/a&gt;Chapter2-1：矩阵的谱半径及应用&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="高等工程数学笔记" scheme="http://yoursite.com/tags/%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>高等工程数学笔记-1</title>
    <link href="http://yoursite.com/2021/09/23/AM1/"/>
    <id>http://yoursite.com/2021/09/23/AM1/</id>
    <published>2021-09-23T04:56:24.632Z</published>
    <updated>2021-09-23T04:53:07.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter1：距离与范数"><a href="#Chapter1：距离与范数" class="headerlink" title="Chapter1：距离与范数"></a>Chapter1：距离与范数</h1><a id="more"></a><h2 id="距离空间"><a href="#距离空间" class="headerlink" title="距离空间"></a>距离空间</h2><p>设 $X$ 是非空集合，对 $X$ 中任意两元素 $x,y$满足，按照某一法则对应唯一的实数$d(x,y)$，且满足下列三条性质：</p><ul><li>非负性：$d(x,y) \geq 0$，$d(x,y)=0$当且仅当$x=y$；</li><li>对称性：$d(x,y)=d(y,x)$；</li><li>三角不等式：$d(x,y) \leq d(x,z)+d(y,z)$. 对所有的$x,y,z \in X$成立.</li></ul><p>则称$d(x,y)$为$x,y$的距离，并称$X$是以$d$为距离的距离空间，记作$(X,d)$。</p><h2 id="完备性"><a href="#完备性" class="headerlink" title="完备性"></a>完备性</h2><p>设$\{x_{n}\}_{n=1}^{\infty}$是距离空间$(X,d)$上的点列，若对于任意的 $\epsilon &gt; 0$，都存在$N \in \mathbb{N}$，当$n,m &gt; N$时有$d(x_{n},x_{m}) &lt; \epsilon$；则称</p><p>$\{x_{n}\}_{n}^{\infty}$为<strong>Cauchy列</strong>。如果$X$中任意<strong>Cauchy</strong>列都在$X$中收敛，则$X$是<strong>完备</strong>的。</p><h2 id="范数与赋范空间"><a href="#范数与赋范空间" class="headerlink" title="范数与赋范空间"></a>范数与赋范空间</h2><p>设$X$是复数域$C$上的线性空间，$0$为$X$的零元素，若对于$X$中每个元素$x$，按照一个法则对应一个实数$||x||$满足：</p><ul><li>$||x|| \geq 0$且$||x||=0$当且仅当$x=0$；</li><li>$||x+y|| \leq ||x||+||y||$；</li><li>$||\alpha x||=|\alpha| \cdot ||x||$；</li></ul><p>则称$||x||$为$x$的<strong>范数</strong>，$X$称为以$||.||$为范数的赋范空间。</p><h2 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h2><p>在$F^{n}$（实或复欧几里得空间）中的向量$x,y$，可以使用$x-y$的范数来描述它们之间的距离。</p><p>令$x = (\xi_{1},\xi_{2},…,\xi_{n})^{T} \in C^{n}$，则：</p><ul><li>1范数：$||x||_{1} = \sum_{k=1}^{n}|\xi_{k}|$（每一维模长的和）</li><li>2范数：$||x||_{2} = \sqrt{\sum_{k=1}^{n}|\xi_{k}|^2}$（每一维模长的平方的和开根）</li><li><p>$\infty$范数：$||x||_{\infty} = max_{k=1}^{n}|\xi_{k}|$（最大的模长）</p></li><li><p>$p$范数：$||x||_{p} = (\sum_{k=1}^{n}|{\xi_{k}}|^p)^{\frac{1}{p}}(1 \leq p \leq \infty)$</p></li></ul><p>$C^{n}$上所有的向量范数等价。</p><p><strong>注：范数等价的一个通俗理解就是可以通过缩放得到其他范数。</strong></p><p>以$p=1,2,\infty$和二维向量$v=(x,y)^T$为例，画出其各自的”单位圆“：</p><p><img src="https://i.loli.net/2021/09/16/i2Vdgfyw6z3qrZ9.jpg" alt="QQ截图20210916095844.jpg" style="zoom:50%;" /></p><p>可以轻松的观察到他们之间是可以缩放的。</p><h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><p>如果$C^{n \times n}$上的一个实函数$||.||:C^{n \times n} \rightarrow R$满足：</p><ul><li>$||A|| \geq 0$，且$||A||=0$的充要条件为$A=0$</li><li>对于$\lambda \in C$有：$||\lambda A|| = |\lambda| \cdot ||A||$</li><li>$||A+B|| \leq ||A||+||B||$</li><li>$||AB|| \leq ||A|| ||B||$</li></ul><p>则称$||.||$是一个矩阵范数，而$||A||$是$C^{n \times n}$上的$A$的矩阵范数。</p><h3 id="矩阵范数的分类及计算"><a href="#矩阵范数的分类及计算" class="headerlink" title="矩阵范数的分类及计算"></a>矩阵范数的分类及计算</h3><p>若$A = (a_{i,j})_{n \times n} \in C^{n \times n}$，则：</p><ul><li>$m_{1}$范数：$||A||_{m_{1}} = \sum_{i=1}^{n}{\sum_{j=1}^{n}}{|a_{i,j}|}$</li><li>$m_{\infty}$范数：$||A||_{m_{\infty}} = n \times max_{i,j}{|a_{i,j}|}$</li><li>$F$范数：$||A||_{F} = \sqrt{\sum_{i=1}^{n}\sum_{j=1}^{n}|a_{i,j}|^2}=\sqrt{tr(A^HA)}=\sqrt{tr(AA^H)}$</li></ul><p>算子范数：</p><script type="math/tex; mode=display">||A||_{m} = \max\limits_{||x||=1} ||Ax||,A \in C^{n \times n}</script><p>根据算子范数可以诱导出矩阵的$1,2, \infty$范数：</p><ul><li>1范数：$||A||_{1} = \max\limits_{j}{\sum_{i=1}^{n}{|a_{i,j}|}}$，极大列和范数</li><li>2范数（谱范数）：$||A||_{2} = \sqrt{\lambda_{1}}$,其中$\lambda_{1}$为$A^{H}A$的最大特征值</li><li>$\infty$范数：$||A||_{\infty} = \max\limits_{i}{\sum_{j=1}^{n}|a_{i,j}|}$，极大行和范数</li></ul><h2 id="矩阵范数与向量范数的相容性"><a href="#矩阵范数与向量范数的相容性" class="headerlink" title="矩阵范数与向量范数的相容性"></a>矩阵范数与向量范数的相容性</h2><p>设$||.||_{m}$是$C^{n \times n}$上的矩阵范数，$||.||_{a}$是$C^{n}$上的向量范数， 如果对于任意的$A \in C^{n \times n}$和$x \in C^{n}$有：</p><script type="math/tex; mode=display">||Ax||_{a} \leq ||A||_{m}||x||_{a}</script><p>则向量范数$||.||_{a}$与矩阵范数$||.||_{m}$是相容的。</p><ul><li>向量$1$范数与矩阵$m_{1}$范数相容</li><li>向量$2$范数与矩阵$F$范数相容</li><li>向量$1,2,\infty$范数都与矩阵的$\infty$范数相容</li></ul><p><strong>定理：任何向量范数都存在与之相容的矩阵范数（算子范数），任何矩阵范数都存在与之相容的向量范数</strong></p><h2 id="酉矩阵"><a href="#酉矩阵" class="headerlink" title="酉矩阵"></a>酉矩阵</h2><p>设$A \in C^{n \times n}$，若$A$满足$A^{H}A=I$,则称$A$为酉矩阵。</p><h3 id="酉矩阵性质"><a href="#酉矩阵性质" class="headerlink" title="酉矩阵性质"></a>酉矩阵性质</h3><ul><li>若$A$是酉矩阵，则$A^{-1},A^{H},A_{T},\overline{A},A^{k}$也是酉矩阵</li><li>若$A,B$是酉矩阵，则$AB$也是酉矩阵</li><li>若$A$是酉矩阵，则$|det(A)|=1$</li><li>$A$是酉矩阵的充要条件是$A$的$n$个列/行向量是标准正交向量组</li><li>$A$是酉矩阵的充要条件是对于任意的$\alpha,\beta \in C^{n}$有：$(A\alpha,A\beta) = (\alpha,\beta)$</li><li>若$A$是酉矩阵，$\lambda$是$A$的特征值，则$|\lambda|=1$</li></ul><h2 id="酉不变性"><a href="#酉不变性" class="headerlink" title="酉不变性"></a>酉不变性</h2><p>对于酉矩阵$U,V$有：</p><ul><li><p>$||UA||_{F}=||AV||_{F}=||UAV||_{F}=||A||_{F}$</p><p>证明：</p><script type="math/tex; mode=display">||UA||_{F} = \sqrt{tr((UA)^{H}UA)}=\sqrt{tr(A^HU^HUA)}=\sqrt{tr(A^HA)}=||A||_{F}</script><p>后面也类似。</p></li><li><p>$||UA||_{2}=||AV||_{2}=||UAV||_{2}=||A||_{2}$</p><p>证明：</p><script type="math/tex; mode=display">||UA||_{2} = \sqrt{\max\limits_{\lambda}((UA)^HUA)} = \sqrt{\max\limits_{\lambda}(A^HA)}=||A||_{2}</script><p><script type="math/tex">||AV||_{2} = \sqrt{\max\limits_{\lambda}(V^HA^HAV)} = \sqrt{\max\limits_{\lambda}(A^HA)}= ||A||_{2}</script>(矩阵相似性)</p></li></ul><h2 id="Hermite矩阵"><a href="#Hermite矩阵" class="headerlink" title="Hermite矩阵"></a>Hermite矩阵</h2><p>对于$A \in C^{n \times n}$，如果：$A^{H}=A$，则$A$是Hermite矩阵，如果$A^{H}=-A$,则$A$是反Hermite矩阵</p><h2 id="正规矩阵（十分重要的概念）"><a href="#正规矩阵（十分重要的概念）" class="headerlink" title="正规矩阵（十分重要的概念）"></a>正规矩阵（十分重要的概念）</h2><p>若$A \in C^{n \times n}$，如果$A^HA=AA^H$，则$A$是正规矩阵。</p><p>如果$A$是正规矩阵，则：$||A||_{2}=\max\limits_{k}|\lambda_{k}|$</p><p>证明：</p><p>$A$是正规矩阵的充要条件是$A$酉相似于对角矩阵，因此有：</p><script type="math/tex; mode=display">U^HAU = \left[\begin{matrix}\lambda_{1}& ... &...\\... & \lambda_{2} & ... \\...&...&...\\ ... & ... & \lambda_{n}\end{matrix}\right]</script><p>故：</p><script type="math/tex; mode=display">A = U\left[\begin{matrix}\lambda_{1}& ... &...\\... & \lambda_{2} & ... \\...&...&...\\ ... & ... & \lambda_{n}\end{matrix}\right]U^H</script><p>因此：</p><script type="math/tex; mode=display">||A||_{2}=\sqrt{\max\limits_{\lambda}(A^HA)}=\sqrt{\max\limits_{\lambda}(U^H\left[\begin{matrix}\\\overline{\lambda_{1}}& ... &...\\... & \overline{\lambda_{2}} & ... \\...&...&...\\ ... & ... & \overline{\lambda_{n}}\end{matrix}\right]\left[\begin{matrix}\lambda_{1}& ... &...\\... & \lambda_{2} & ... \\...&...&...\\ ... & ... & \lambda_{n}\end{matrix}\right]U) }=\max\limits_{k}|\lambda_{k}|</script><p>Q.E.D</p><p>此外正规矩阵还有一些其他的性质：</p><ul><li><p>$||A^H||_{m_{1},F,m_{\infty}}=||A||_{m_{1},F,m_{\infty}}$</p></li><li><p>$||A^H||_{1,2,\infty} = ||A||_{\infty,2,1}$</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chapter1：距离与范数&quot;&gt;&lt;a href=&quot;#Chapter1：距离与范数&quot; class=&quot;headerlink&quot; title=&quot;Chapter1：距离与范数&quot;&gt;&lt;/a&gt;Chapter1：距离与范数&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="高等工程数学笔记" scheme="http://yoursite.com/tags/%E9%AB%98%E7%AD%89%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>力扣周赛251题解</title>
    <link href="http://yoursite.com/2021/09/19/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B251%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/09/19/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B251%E9%A2%98%E8%A7%A3/</id>
    <published>2021-09-19T05:51:12.657Z</published>
    <updated>2021-07-29T12:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣周赛251题解"><a href="#力扣周赛251题解" class="headerlink" title="力扣周赛251题解"></a>力扣周赛251题解</h1><a id="more"></a><h2 id="T1-字符串转化后的各位数字之和"><a href="#T1-字符串转化后的各位数字之和" class="headerlink" title="T1.字符串转化后的各位数字之和"></a>T1.字符串转化后的各位数字之和</h2><p>字符串转化后的各位数字之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLucky</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=c-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                d.push_back(k/<span class="number">10</span>);</span><br><span class="line">                d.push_back(k%<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tt=<span class="number">1</span>;tt&lt;=k;tt++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:d)&#123;</span><br><span class="line">                ans+=v;</span><br><span class="line">            &#125;</span><br><span class="line">            d.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(ans)&#123;</span><br><span class="line">                d.push_back(ans%<span class="number">10</span>);</span><br><span class="line">                ans/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:d)&#123;</span><br><span class="line">            res=res*<span class="number">10</span>+v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T2-子字符串突变后可能得到的最大整数"><a href="#T2-子字符串突变后可能得到的最大整数" class="headerlink" title="T2. 子字符串突变后可能得到的最大整数"></a>T2. 子字符串突变后可能得到的最大整数</h2><p>贪心，找到第一个能够变大的为止，以其为起点突变即可，直到遇到一个突变后会变小的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maximumNumber</span><span class="params">(<span class="built_in">string</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> id=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(change[num[i]-<span class="string">'0'</span>]+<span class="string">'0'</span>&gt;num[i])&#123;</span><br><span class="line">                id=i;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=id;i&lt;n;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(change[num[i]-<span class="string">'0'</span>]+<span class="string">'0'</span>&gt;=num[i])&#123;</span><br><span class="line">                num[i]=change[num[i]-<span class="string">'0'</span>]+<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T3-最大兼容性评分和"><a href="#T3-最大兼容性评分和" class="headerlink" title="T3.最大兼容性评分和"></a>T3.最大兼容性评分和</h2><p>实际上利用next-permutation函数可以通过本题…比赛的时候想复杂了，使用了状压dp。</p><p>令$dp[i][status]$表示前$i$个学生已经选择了$status$导师。</p><p>则状态转移方程为：</p><script type="math/tex; mode=display">dp[i][status|(1<<j)]=max(dp[i][status|(1<<j)],dp[i-1][status]+cost(i,j))</script><p>其中$cost(i,j)$表示学生$i$跟随导师$j$的兼容性评分，时间复杂度为$O(n\cdot m^2 \cdot 2^m)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">1</span>&lt;&lt;<span class="number">8</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[i])&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitcount</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans+=(x&amp;<span class="number">1</span>);</span><br><span class="line">            x/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCompatibilitySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; students, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mentors)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=(<span class="keyword">int</span>)students.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> last=<span class="number">0</span>;last&lt;(<span class="number">1</span>&lt;&lt;m);last++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((((last&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>)==<span class="number">0</span>)&amp;&amp;bitcount(last)==i<span class="number">-1</span>)&#123;</span><br><span class="line">                        dp[i][last|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]=<span class="built_in">max</span>( dp[i][last|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))],dp[i<span class="number">-1</span>][last]+cal(students[i<span class="number">-1</span>],mentors[j<span class="number">-1</span>]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T4-删除系统中的重复文件夹"><a href="#T4-删除系统中的重复文件夹" class="headerlink" title="T4.删除系统中的重复文件夹"></a>T4.删除系统中的重复文件夹</h2><p>卡常卡到爆炸…</p><p>考虑根据所有的文件路径复原出文件树，文件树的复原过程类似于字典树的构建过程。</p><p>接下来对于构造出来的文件树进行DFS，利用DFS求出以$node$为根节点的子树的所有文件的hash值。</p><p>最后只要当前子树的hash值出现过，则当前子树就要被删除。</p><p>最后再利用一次DFS遍历出答案即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    ll hash_val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; sons;</span><br><span class="line">    Node(<span class="built_in">string</span> s,<span class="keyword">int</span> id):s(s),id(id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;Node*,<span class="built_in">string</span>&gt;,Node*&gt; nxt;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; id;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec,Node *node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s:vec)&#123;</span><br><span class="line">            <span class="keyword">bool</span> <span class="built_in">find</span>=<span class="number">0</span>;</span><br><span class="line">            Node *p = nxt[&#123;node,s&#125;];</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;</span><br><span class="line">                node=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Node *v = <span class="keyword">new</span> Node(s,id[s]);</span><br><span class="line">                node-&gt;sons.push_back(v);</span><br><span class="line">                nxt[&#123;node,s&#125;]=v;</span><br><span class="line">                node=v;                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">Gethash</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            ans=(ans*base%mod+(<span class="keyword">int</span>)c)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Node* u)</span></span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:u-&gt;sons)&#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">            ll t=(v-&gt;hash_val*base%mod+Gethash(v-&gt;s))%mod;</span><br><span class="line">            ans=(ans*base%mod+t)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[ans]++;</span><br><span class="line">        u-&gt;hash_val=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFSS</span><span class="params">(Node* u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[u-&gt;hash_val]&gt;<span class="number">1</span>&amp;&amp;u-&gt;hash_val)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s!=<span class="string">"/"</span>)&#123;</span><br><span class="line">            tmp.push_back(u-&gt;s);</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:u-&gt;sons)&#123;</span><br><span class="line">            DFSS(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()) tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">deleteDuplicateFolder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        Node *root = <span class="keyword">new</span> Node(<span class="string">"/"</span>,<span class="number">1</span>);</span><br><span class="line">        Node *p=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:paths)&#123;</span><br><span class="line">            Insert(v,p);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(root);</span><br><span class="line">        DFSS(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;力扣周赛251题解&quot;&gt;&lt;a href=&quot;#力扣周赛251题解&quot; class=&quot;headerlink&quot; title=&quot;力扣周赛251题解&quot;&gt;&lt;/a&gt;力扣周赛251题解&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>矩阵分解推荐算法（LMF）</title>
    <link href="http://yoursite.com/2021/09/19/MF/"/>
    <id>http://yoursite.com/2021/09/19/MF/</id>
    <published>2021-09-19T05:51:12.641Z</published>
    <updated>2019-05-21T13:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵分解推荐算法（LMF）"><a href="#矩阵分解推荐算法（LMF）" class="headerlink" title="矩阵分解推荐算法（LMF）"></a>矩阵分解推荐算法（LMF）</h1><a id="more"></a><p>首先我们现在有一个矩阵$R_{mn}$，其中$R_{ij}$代表第$i$个用户对第$j$个商品的喜爱程度。</p><p>$LMF$算法认为每个商品上面都有一些隐因子，而顾客的喜爱程度是由这些隐因子来决定的。因此便可以将$R_{mn}$分解成$P_{mF} \times Q_{Fn}$的形式。<br>矩阵$P_{mF}$代表了这$m$个用户对$F$个隐因子的喜爱程度，$Q_{Fn}$代表这$F$个隐因子在这$n$个商品上的分布概率。</p><center>$R'_{ij}=\sum_{f=1}^F {P_{if}Q_{fj}}$ </center>我们最终的目的是使得$R_{ij}$和$R'_ {ij}$尽可能的相近。因此，损失函数为:<center>$f(P,Q)=\sum{(R_{ij}-R'_{ij})^2}$ </center><p>为了防止过拟合，需要加上一个正则项来防止$P_{if},Q_{fj}$过小或过大。</p><center>$f(P,Q)=\sum{(R_{ij}-R'_{ij})^2}+\lambda(\sum{(P_{if}^2}+\sum{Q_{fj}^2})$ </center><p>接下来就是对这个函数用梯度下降进行拟合，递推式为：</p><center>$P_{k+1}=P_{k}-\alpha\frac{\partial f(P,Q)}{\partial P_k}$ </center><center>$Q_{k+1}=Q_{k}-\alpha\frac{\partial f(P,Q)}{\partial Q_k}$ </center><p>这样我们采用梯度下降算法即可获得$R’$矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="comment">##将R_nm分解成P_nk*Q_km</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MF</span><span class="params">(R,P,Q,K,times=<span class="number">100000</span>,alp=<span class="number">0.0001</span>,lb=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">  <span class="comment">#  Q=Q.T</span></span><br><span class="line">    <span class="keyword">for</span> steps <span class="keyword">in</span> range(times):<span class="comment"># 迭代次数</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> range(len(R)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(R[u])):</span><br><span class="line">                <span class="keyword">if</span> R[u][i]&gt;<span class="number">0</span>:</span><br><span class="line">                    delta=R[u][i]-numpy.dot(P[u,:],Q[:,i])</span><br><span class="line">                <span class="keyword">for</span> f <span class="keyword">in</span> range(K):</span><br><span class="line">                    P[u][f]=P[u][f]+<span class="number">2</span>*alp*(delta*Q[f][i]-lb*P[u][f])<span class="comment">#递推运算</span></span><br><span class="line">                    Q[f][i]=Q[f][i]+<span class="number">2</span>*alp*(delta*P[u][f]-lb*Q[f][i])</span><br><span class="line">    <span class="keyword">return</span> P,Q</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    R=[</span><br><span class="line">        [<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">        [<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">    ]</span><br><span class="line">    K=<span class="number">2</span></span><br><span class="line">    n=len(R)</span><br><span class="line">    m=len(R[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">##随机生成P,Q矩阵</span></span><br><span class="line">    P=numpy.random.rand(n,K)</span><br><span class="line">    Q=numpy.random.rand(K,m)</span><br><span class="line">    <span class="comment">##矩阵分解</span></span><br><span class="line">    ansp,ansq=MF(R,P,Q,K)</span><br><span class="line">    ansR=numpy.dot(ansp,ansq)</span><br><span class="line">    print(ansR)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;矩阵分解推荐算法（LMF）&quot;&gt;&lt;a href=&quot;#矩阵分解推荐算法（LMF）&quot; class=&quot;headerlink&quot; title=&quot;矩阵分解推荐算法（LMF）&quot;&gt;&lt;/a&gt;矩阵分解推荐算法（LMF）&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>网络流24题</title>
    <link href="http://yoursite.com/2021/09/19/Maxflow/"/>
    <id>http://yoursite.com/2021/09/19/Maxflow/</id>
    <published>2021-09-19T05:51:12.641Z</published>
    <updated>2019-10-10T08:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络流24题"><a href="#网络流24题" class="headerlink" title="网络流24题"></a>网络流24题</h1><a id="more"></a><h2 id="搭配飞行员"><a href="#搭配飞行员" class="headerlink" title="搭配飞行员"></a><a href="https://loj.ac/problem/6000" target="_blank" rel="noopener">搭配飞行员</a></h2><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>二分图最大匹配，从$S$往每个正驾驶连接一条流量为$1$的边，从每个副驾驶往$T$连接一条流量为$1$的边，两个可以配合的飞行员之间连接一条流量为$1$的边,跑最大流即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S,T,n,m,w[N],dep[N],head[N],to[N],num=<span class="number">1</span>,sum=<span class="number">0</span>,x,nxt[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    to[num]=v;nxt[num]=head[u];w[num]=ww;head[u]=num;</span><br><span class="line">    num++;</span><br><span class="line">    to[num]=u;nxt[num]=head[v];w[num]=<span class="number">0</span>;head[v]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    vis[S]=<span class="number">1</span>;q.push(S);dep[S]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[v]||w[i]&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            vis[v]=<span class="number">1</span>;q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T||d==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]!=dep[u]+<span class="number">1</span>||w[i]&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> flow=dfs(v,min(d,w[i]));</span><br><span class="line">        d-=flow;ret+=flow;</span><br><span class="line">        w[i]-=flow;w[i^<span class="number">1</span>]+=flow;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">0</span>) dep[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    S=<span class="number">0</span>;T=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) add(S,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;i++) add(i,T,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v))&#123;</span><br><span class="line">        add(u,v,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) sum+=dfs(S,INF);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="太空飞行计划"><a href="#太空飞行计划" class="headerlink" title="太空飞行计划"></a><a href="https://loj.ac/problem/6001" target="_blank" rel="noopener">太空飞行计划</a></h2><h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>最大权闭合子图，设$V’$为$G(V,E)$的一个点集，如果$V$中对于每个点的所有的出边所到达的点也$\in V’$，那么$V’$即为一个闭合子图，最大权闭合子图即为所有的闭合子图中权值和最大的。</p><p>定理：从$S$向所有权值为正数的点增加一条等于该点点权的流量的边，从所有权值为负数的点向$T$增加一条等于该点权绝对值流量的边，对于$u(w_{u}&gt;0)$，假设完成$u$需要集合$I_{u}$，则对$v \in I_{u}$连接一条权值流量为$inf$的边，跑一边最小割即可。</p><p>意义：割掉$S-&gt;u$代表不进行任务$u$，割掉$v-&gt;T$代表需要使用$v$，最后$S$可达的即为要选择的。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S,T,n,m,w[N],dep[N],head[N],to[N],num=<span class="number">1</span>,sum=<span class="number">0</span>,x,nxt[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    to[num]=v;nxt[num]=head[u];w[num]=ww;head[u]=num;</span><br><span class="line">    num++;</span><br><span class="line">    to[num]=u;nxt[num]=head[v];w[num]=<span class="number">0</span>;head[v]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    vis[S]=<span class="number">1</span>;q.push(S);dep[S]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[v]||w[i]&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            vis[v]=<span class="number">1</span>;q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T||d==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]!=dep[u]+<span class="number">1</span>||w[i]&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> flow=dfs(v,min(d,w[i]));</span><br><span class="line">        d-=flow;ret+=flow;</span><br><span class="line">        w[i]-=flow;w[i^<span class="number">1</span>]+=flow;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">0</span>) dep[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1000</span>],p[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    S=n+m+<span class="number">1</span>;T=n+m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">        sum+=p[i];</span><br><span class="line">        add(S,i,p[i]);</span><br><span class="line">        <span class="keyword">while</span>(getchar()==<span class="string">' '</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            add(i,n+x,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">         add(i+n,T,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) sum-=dfs(S,INF);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; task,<span class="built_in">exp</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">             task.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="built_in">exp</span>.push_back(i-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,task[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="keyword">int</span>)task.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,task[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">exp</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">exp</span>.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,<span class="built_in">exp</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a><a href="https://loj.ac/problem/6002" target="_blank" rel="noopener">最小路径覆盖</a></h2><h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>假设$x,y$之间有一条边，则把$x$和$y$分别拆成$x_1,x_2,y_1,y_2$。在$x_1$和$y_2$之间连接一条流量为$1$的边，构造好二分图后答案即为$n-maxmatch$。对于方案的输出，可以利用并查集，对于$x$和$y$，如果流量流经$x-&gt;y$，则$x-&gt;y$在一条路径上，最后$O(n^2)$输出即可。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S,T,n,m,w[N],to[N],dep[N],head[N],nxt[N],num=<span class="number">1</span>,u,v,pre[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    to[num]=v;nxt[num]=head[u];w[num]=ww;head[u]=num;</span><br><span class="line">    num++;</span><br><span class="line">    to[num]=u;nxt[num]=head[v];w[num]=<span class="number">0</span>;head[v]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dep[S]=<span class="number">0</span>;</span><br><span class="line">    vis[S]=<span class="number">1</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[v]||w[i]&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T||d==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]!=dep[u]+<span class="number">1</span>||w[i]&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> flow=dfs(v,min(w[i],d));<span class="comment">//增广的流量</span></span><br><span class="line">        d-=flow;ret+=flow;</span><br><span class="line">        w[i]-=flow;w[i^<span class="number">1</span>]+=flow;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;<span class="comment">//无法增广</span></span><br><span class="line">        dep[u]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i++) par[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==par[x]?x:par[x]=find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=find(x);y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ;</span><br><span class="line">    par[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    S=<span class="number">0</span>;T=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v+n,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(S,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) add(i,T,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans-=dfs(S,INF);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j;j=nxt[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(to[j]&amp;&amp;!w[j]&amp;&amp;to[j]&lt;=<span class="number">2</span>*n)&#123;<span class="comment">//如果i-&gt;to[j]还有流量</span></span><br><span class="line">                unite(i,to[j]-n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> check=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(j)==i)&#123;</span><br><span class="line">                check=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络流24题&quot;&gt;&lt;a href=&quot;#网络流24题&quot; class=&quot;headerlink&quot; title=&quot;网络流24题&quot;&gt;&lt;/a&gt;网络流24题&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>浅谈序列自动机</title>
    <link href="http://yoursite.com/2021/09/19/SuATM/"/>
    <id>http://yoursite.com/2021/09/19/SuATM/</id>
    <published>2021-09-19T05:51:12.641Z</published>
    <updated>2019-07-24T01:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈序列自动机"><a href="#浅谈序列自动机" class="headerlink" title="浅谈序列自动机"></a>浅谈序列自动机</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>序列自动机是一个可以快速判断字符串$t$是否是字符串$s$的子串的一个算法。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>对$s$构造序列自动机，使用$Nxt_{i,j}$代表从第$i$个位置开始，字符$j$出现的第一个位置。我们倒着遍历更新即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int nxt[N][27];</span><br><span class="line">void init(char *s)&#123;</span><br><span class="line">int l&#x3D;strlen(s);</span><br><span class="line">for(int i&#x3D;0;i&lt;26;i++) nxt[l][i]&#x3D;INF;</span><br><span class="line">for(int i&#x3D;l-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">for(int j&#x3D;0;j&lt;26;j++)&#123;</span><br><span class="line">nxt[i][j]&#x3D;nxt[i+1][j];</span><br><span class="line">&#125;</span><br><span class="line">nxt[i][s[i]-&#39;a&#39;]&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>设置初始指针$p$为-1，每次让$p$跳到$Nxt_{p+1,j}$上面，$j$为当前查询的字符，如果$p$为$INF$,则说明找不到下一个字符，即$t$不是$s$的子串。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">pos=nxt[pos+<span class="number">1</span>][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(pos==INF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_AM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt[N][<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) nxt[l][i]=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">nxt[i][j]=nxt[i+<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">nxt[i][s[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">pos=nxt[pos+<span class="number">1</span>][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(pos==INF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;solve;</span><br></pre></td></tr></table></figure><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p><a href="https://nanti.jisuanke.com/t/38232" target="_blank" rel="noopener">计蒜客 Subsquenece</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">char</span> t[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_AM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt[N][<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) nxt[l][i]=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">nxt[i][j]=nxt[i+<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">nxt[i][s[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">pos=nxt[pos+<span class="number">1</span>][t[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(pos==INF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;solve;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">solve.init(s);</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line"><span class="keyword">if</span>(solve.find(t))&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浅谈序列自动机&quot;&gt;&lt;a href=&quot;#浅谈序列自动机&quot; class=&quot;headerlink&quot; title=&quot;浅谈序列自动机&quot;&gt;&lt;/a&gt;浅谈序列自动机&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="字符串算法" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客暑期多校D.Big Integer</title>
    <link href="http://yoursite.com/2021/09/19/nowcoder3D/"/>
    <id>http://yoursite.com/2021/09/19/nowcoder3D/</id>
    <published>2021-09-19T05:51:12.641Z</published>
    <updated>2019-08-05T12:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019牛客暑期多校D-Big-Integer"><a href="#2019牛客暑期多校D-Big-Integer" class="headerlink" title="2019牛客暑期多校D.Big Integer"></a>2019牛客暑期多校D.Big Integer</h1><a id="more"></a><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://ac.nowcoder.com/acm/contest/883/D" target="_blank" rel="noopener">题面</a></h2><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>定义$A(n)$为$n$个1构成的数字，如$A(3)=111$，计算有多少对$(i,j)$使得$A(i^j) \% p = 0$。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>通过枚举发现是有上面的等式是有循环节的，而且循环节是$p-1$的因子，因此暴力枚举计算出循环节$d$，接下来就是求有多少对$i^j \% d=0$。<br>将$d$进行质因子分解，得</p><script type="math/tex; mode=display">d={p_1}^{q_1} \cdot {p_2}^{q_2} \cdot {p_3}^{q_3} ...{p_k}^{q_k}</script><p>那么要使$i^j \%d = 0$，则$i$必须为</p><script type="math/tex; mode=display">g={p_1}^{\lceil {\frac{q_1}{j}} \rceil} \cdot {p_2}^{\lceil {\frac{q_2}{j}} \rceil} \cdot {p_3}^{\lceil {\frac{q_3}{j}} \rceil} ...{p_k}^{\lceil {\frac{q_k}{j}} \rceil}</script><p>的倍数。因此一共有$\frac{n}{g}$个合法的$i$<br>由于$q_i \leq 30$，因此$j$在$30$之后和$30$的答案相同，因此$j$只需要枚举到$[1,30]$，分别计算出$g$的值。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans%mod*a%mod)%mod;</span><br><span class="line">        a=(a%mod*a%mod)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a);</span><br><span class="line">a=(a*a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p,n,m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; pr;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> re;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;p,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n/<span class="number">3</span>*m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; all;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=p<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((p<span class="number">-1</span>)%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i*i==p<span class="number">-1</span>) all.push_back(i);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    all.push_back(i);</span><br><span class="line">                    all.push_back((p<span class="number">-1</span>)/i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        all.push_back(p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;<span class="comment">//循环节</span></span><br><span class="line">        sort(all.begin(),all.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:all)&#123;<span class="comment">//找到循环节</span></span><br><span class="line">            <span class="keyword">if</span>((qpow(<span class="number">10</span>,v,p))%p==<span class="number">1</span>)&#123;</span><br><span class="line">                id=v;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=id;i++)&#123;<span class="comment">//质因子分解</span></span><br><span class="line">            <span class="keyword">if</span>(id%i==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">                pr.push_back(i);</span><br><span class="line">                <span class="keyword">while</span>(id%i==<span class="number">0</span>)&#123;</span><br><span class="line">                 id/=i;</span><br><span class="line">                 num++;</span><br><span class="line">                &#125;</span><br><span class="line">                nums.push_back(num);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(id!=<span class="number">1</span>)&#123;</span><br><span class="line">         pr.push_back(id);</span><br><span class="line">         nums.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=min((<span class="keyword">long</span> <span class="keyword">long</span>)m,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">30</span>);j++)&#123;</span><br><span class="line">        g=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)nums.size();i++)&#123;</span><br><span class="line">        g*=qp(pr[i],(nums[i]+j<span class="number">-1</span>)/j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">30</span>) ans+=(n/g)*(m<span class="number">-29</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=n/g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2019牛客暑期多校D-Big-Integer&quot;&gt;&lt;a href=&quot;#2019牛客暑期多校D-Big-Integer&quot; class=&quot;headerlink&quot; title=&quot;2019牛客暑期多校D.Big Integer&quot;&gt;&lt;/a&gt;2019牛客暑期多校D.Big Integer&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>对主席树的理解以及使用</title>
    <link href="http://yoursite.com/2021/09/19/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://yoursite.com/2021/09/19/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2021-09-19T05:51:12.641Z</published>
    <updated>2020-04-08T02:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对主席树的理解以及使用"><a href="#对主席树的理解以及使用" class="headerlink" title="对主席树的理解以及使用"></a>对主席树的理解以及使用</h1> <a id="more"></a><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>一个长度为$n$的数组，有$m$次查询，每次查询区间$[l,r]$内第$k$小的元素。</p><p>如果使用暴力，肯定不可以</p><p>使用线段树？可是我只会查询区间最值啊。</p><p>那么我们把问题再次简化一下，查询$[1,n]$第$k$小的元素，要求使用线段树来实现。</p><h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>为了解决这个问题，我们引入一个名词:<strong>权值线段树</strong>。那么权值线段树是如何解决上面那个问题的呢？</p><p>首先，我们对数组进行离散化处理，离散成为$[1,n]$，然后我们建一颗线段树，线段树的节点存放的即为对应区间的数的个数。</p><p>比如数组$a={3,3,2,2}$,经过离散化后变为$2,2,1,1$。</p><p>对应的线段树即为：</p><p> <img src="https://i.loli.net/2019/07/30/5d3feb07f205312086.png" alt=""></p><p>建好线段树之后我们如何求解第$k$小元素呢？我们从根节点出发，看下它的左儿子的元素个数是否超过了$k$，如果超过了$k$，那么第$k$小一定是左儿子的第$k$小，我们直接去访问左儿子，否则，假设左儿子的节点为$num$，那么第$k$小一定是右儿子的第$k-num$小，我们去访问右儿子，直到递归终止，我们便找到了第$k$小元素。</p><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>当我们解决了上一个问题，我们这样考虑：</p><p>每输入一个数字$a_i$，就建一棵$[1,i]$的权值线段树，那么如果要查询$[l,r]$的区间第$k$小，直接让这两棵权值线段树做差，然后进行我们上面设计的算法，问题不久迎刃而解了吗？</p><p>但是，每建一棵树，这样$n$棵树的空间会达到$O(n^2)$的级别，空间是无法承受的。我们这样想，假设你输入了$a_i$，并且你已经建好了$a_{i-1}$的线段树，是不是$a_i$和$a_{i-1}$的线段树只会有$log$级别的点是不同的，剩下的大部分都是完全一致的。利用这个性质，我们不再开辟新的线段树，而是先把$a_i$会改变掉的节点复制一份，然后对复制的节点进行修改，连接到上次构建好的线段树上，这样我们只用了$log$的空间。最终我们构造的这棵树就叫主席树（其实已经不是一棵树了）。点的个数最多为$O(nlog(n))$。</p><h2 id="建立过程"><a href="#建立过程" class="headerlink" title="建立过程"></a>建立过程</h2><p>对于数组$a:3,3,2,2$建立主席树:</p><p>第一步：离散化为$2,2,1,1$<br>第二步：输入$2$，构造权值线段树</p><p><img src="https://i.loli.net/2019/07/30/5d3ff004ecc4522556.png" alt=""></p><p>第三步：输入2</p><p><img src="https://i.loli.net/2019/07/30/5d3ff0bc8bb4530476.png" alt="2.png"></p><p>第四步:输入1</p><p><img src="https://i.loli.net/2019/07/30/5d3ff2433ccd810571.png" alt="3.png"></p><p>第五步:输入1</p><p><img src="https://i.loli.net/2019/07/30/5d3ff2e2ec71e19358.png" alt="4.png"></p><p>这样我们就构造了一个主席树（有点丑），然后对于要查询的区间$[l,r]$，我们只需要从他们各自的”根”出发，递归做差寻找第$k$大即可。图中四个根分别为$1,4,7,10$。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v;</span><br><span class="line">ll a[N],roots[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll l,r,num;</span><br><span class="line">&#125;T[N*<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l,ll r,ll &amp;x,ll y,ll pos)</span></span>&#123;</span><br><span class="line">T[++cnt]=T[y];T[cnt].num++;x=cnt;<span class="comment">//复制节点并且更新</span></span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=pos) update(l,mid,T[x].l,T[y].l,pos);</span><br><span class="line"><span class="keyword">else</span> update(mid+<span class="number">1</span>,r,T[x].r,T[y].r,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r,ll x,ll y,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">ll sum=T[T[y].l].num-T[T[x].l].num;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> query(l,mid,T[x].l,T[y].l,k);<span class="comment">//第$k$小在左子树</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(mid+<span class="number">1</span>,r,T[x].r,T[y].r,k-sum);<span class="comment">//在右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getid</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lower_bound(v.begin(),v.end(),x)-v.begin()+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">ll n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),v.push_back(a[i]);</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line"></span><br><span class="line">v.erase(unique(v.begin(),v.end()),v.end());<span class="comment">//离散化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) update(<span class="number">1</span>,n,roots[i],roots[i<span class="number">-1</span>],getid(a[i]));</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">ll l,r,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,v[query(<span class="number">1</span>,n,roots[l<span class="number">-1</span>],roots[r],k)<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对主席树的理解以及使用&quot;&gt;&lt;a href=&quot;#对主席树的理解以及使用&quot; class=&quot;headerlink&quot; title=&quot;对主席树的理解以及使用&quot;&gt;&lt;/a&gt;对主席树的理解以及使用&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣周赛252题解</title>
    <link href="http://yoursite.com/2021/09/19/LC252/"/>
    <id>http://yoursite.com/2021/09/19/LC252/</id>
    <published>2021-09-19T05:51:12.625Z</published>
    <updated>2022-11-06T08:22:18.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣周赛252题解"><a href="#力扣周赛252题解" class="headerlink" title="力扣周赛252题解"></a>力扣周赛252题解</h1><a id="more"></a><h2 id="T1-三除数"><a href="#T1-三除数" class="headerlink" title="T1. 三除数"></a>T1. 三除数</h2><p>直接枚举因子个数，时间复杂度为$O(\sqrt{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i*i==n)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans+=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans==<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T2-你可以工作的最大周数"><a href="#T2-你可以工作的最大周数" class="headerlink" title="T2. 你可以工作的最大周数"></a>T2. 你可以工作的最大周数</h2><p>如果阶段任务最多的可以做完，则剩余的也一定可以做完。</p><p>假设除了最多的阶段任务，剩下的阶段任务有$res$个。</p><p>答案为$min(2*res+1,n)$，$n$为总个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">numberOfWeeks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; milestones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:milestones)&#123;</span><br><span class="line">            s+=v;</span><br><span class="line">            maxx=max(maxx,v*<span class="number">1L</span>L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=s-maxx;</span><br><span class="line">        <span class="keyword">return</span> min(s,<span class="number">2</span>*res+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T3-收集足够苹果的最小花园周长"><a href="#T3-收集足够苹果的最小花园周长" class="headerlink" title="T3. 收集足够苹果的最小花园周长"></a>T3. 收集足够苹果的最小花园周长</h2><p>假设右上角顶点坐标为$(n,n)$，则第一象限的苹果个数为：</p><p>$n<em>n</em>(n+1)$，则总的苹果个数为$4<em>n</em>n<em>(n+1)+2</em>(n+1)*n$。</p><p>二分/暴力即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> first=x*x*(x+<span class="number">1</span>)*<span class="number">4</span>+<span class="number">2</span>*(x+<span class="number">1</span>)*x;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minimumPerimeter</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> ned)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>,r=<span class="number">5e5</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(cal(mid)&gt;=ned)&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>*(r+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T4-统计特殊子序列的数目"><a href="#T4-统计特殊子序列的数目" class="headerlink" title="T4. 统计特殊子序列的数目"></a>T4. 统计特殊子序列的数目</h2><p>令$dp[i][j]$表示$a_{1},…,a_{i}$中以$j$结尾的特殊子序列个数。</p><p>则有：</p><p>$dp[i][0]=2*dp[i-1][0]+1$</p><p>$dp[i][1]=2*dp[i-1][1]+dp[i-1][0]$</p><p>$dp[i][2]=2*dp[i-1][2]+dp[i-1][1]$</p><p>实际上可以做到空间$O(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSpecialSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> A,B,C;</span><br><span class="line">        A=B=C=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==<span class="number">0</span>) A=A*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(v==<span class="number">1</span>) B=<span class="number">2</span>*B+A;</span><br><span class="line">            <span class="keyword">if</span>(v==<span class="number">2</span>) C=<span class="number">2</span>*C+B;</span><br><span class="line">            A%=mod;</span><br><span class="line">            B%=mod;</span><br><span class="line">            C%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p><img src="C:\Users\23120\AppData\Roaming\Typora\typora-user-images\image-20221106162215445.png" alt="image-20221106162215445"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;力扣周赛252题解&quot;&gt;&lt;a href=&quot;#力扣周赛252题解&quot; class=&quot;headerlink&quot; title=&quot;力扣周赛252题解&quot;&gt;&lt;/a&gt;力扣周赛252题解&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣周赛253题解</title>
    <link href="http://yoursite.com/2021/09/19/LC253/"/>
    <id>http://yoursite.com/2021/09/19/LC253/</id>
    <published>2021-09-19T05:51:12.625Z</published>
    <updated>2021-08-08T04:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣周赛253题解"><a href="#力扣周赛253题解" class="headerlink" title="力扣周赛253题解"></a>力扣周赛253题解</h1><a id="more"></a><p>吐槽：大家都挺能卷的，打不过，打不过…</p><p><img src="https://i.loli.net/2021/08/08/ME7byN2AL8eCjY5.jpg" alt="QQ截图20210808114910.jpg"></p><h2 id="T1-检查字符串是否为数组前缀"><a href="#T1-检查字符串是否为数组前缀" class="headerlink" title="T1. 检查字符串是否为数组前缀"></a>T1. 检查字符串是否为数组前缀</h2><p>暴力即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrefixString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> now=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now==s)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now+=v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now==s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T2-移除石子使总数最小"><a href="#T2-移除石子使总数最小" class="headerlink" title="T2.移除石子使总数最小"></a>T2.移除石子使总数最小</h2><p>贪心，每次选择石子数目最多的石子堆执行操作，用大根堆维护，时间复杂度为$O(klog(n))$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStoneSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:piles)&#123;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> test=<span class="number">1</span>;test&lt;=k;test++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.top();q.pop();</span><br><span class="line">            u-=u/<span class="number">2</span>;</span><br><span class="line">            q.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            ans+=q.top();q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T3-使字符串平衡的最小交换次数"><a href="#T3-使字符串平衡的最小交换次数" class="headerlink" title="T3.使字符串平衡的最小交换次数"></a>T3.使字符串平衡的最小交换次数</h2><p>计算该字符串的balance，由于’[‘和’]’的数目相同，因此剩下的失配的也一定相同。</p><p>剩下的适配的子序列可以写成如下形式：</p><p>balance个]后面balance个[</p><p>对于每次交换，实际上就是把[变成]，把]变成[，显然答案为$\lceil\frac{balance}{2}\rceil$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'['</span>) balance++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(balance) --balance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (balance+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="T4-找出到每个位置为止最长的有效障碍赛跑路线"><a href="#T4-找出到每个位置为止最长的有效障碍赛跑路线" class="headerlink" title="T4. 找出到每个位置为止最长的有效障碍赛跑路线"></a>T4. 找出到每个位置为止最长的有效障碍赛跑路线</h2><p>题意就是对于每个$i$，求以$a_{i}$结尾的最长非递减上升子序列的长度。</p><p>只需要把经典的非递减上升子序列的求法中二分INF改成二分$a_{i}+1$即可。时间复杂度为$O(nlog(n))$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">longestObstacleCourseAtEachPosition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)a.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,INF)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=upper_bound(dp.begin(),dp.end(),a[i])-dp.begin();</span><br><span class="line">            dp[x]=a[i];</span><br><span class="line">            ans[i]=lower_bound(dp.begin(),dp.end(),a[i]+<span class="number">1</span>)-dp.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;力扣周赛253题解&quot;&gt;&lt;a href=&quot;#力扣周赛253题解&quot; class=&quot;headerlink&quot; title=&quot;力扣周赛253题解&quot;&gt;&lt;/a&gt;力扣周赛253题解&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>数论知识点总结</title>
    <link href="http://yoursite.com/2021/09/19/Math/"/>
    <id>http://yoursite.com/2021/09/19/Math/</id>
    <published>2021-09-19T05:51:12.625Z</published>
    <updated>2019-05-02T03:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数论知识点总结"><a href="#数论知识点总结" class="headerlink" title="数论知识点总结"></a>数论知识点总结</h1><a id="more"></a><h2 id="1-gcd-（最大公约数）"><a href="#1-gcd-（最大公约数）" class="headerlink" title="$1.gcd$（最大公约数）"></a>$1.gcd$（最大公约数）</h2><p>对于给出的两个数$a,b$，我们可以用欧几里得算法来计算最大公约数。欧几里得算法的精髓就在于下面这个公式：<br>$gcd(a,b)=gcd(b,a$%$b)$</p><p>证明：<br>已知：$gcd(a,b)|a$并且$gcd(a,b)|b$,设$a$%$b=r$,则$a=r+kb$,故$r=a-kb$,根据同余关系可得：$r$%$gcd(a,b)=0$,因此$gcd(a,b)=gcd(b,a$%$b)$</p><p>code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-exgcd-（扩展欧几里得算法）"><a href="#2-exgcd-（扩展欧几里得算法）" class="headerlink" title="$2.exgcd$（扩展欧几里得算法）"></a>$2.exgcd$（扩展欧几里得算法）</h2><p>扩展欧几里得算法是用于求解$ax+by=gcd(a,b)$的一组解的算法。<br>根据欧几里得算法我们可知：$gcd(a,b)=gcd(b,a$%$b)$<br>我们假设$x1,y1$是满足条件的一组解</p><p>那么$ax1+by1=gcd(a,b)$</p><p>而$gcd(a,b)=gcd(b,a$%$b)$</p><p>故$ax1+by1=bx2+a$%$by2$</p><p>而$a$%$b=a-a/b\ast b$</p><p>因而$ax1+by1=bx2+ay2-a/b\ast by2=ay2+b*(x2-<br>a/b\ast y2)$</p><p>那么我们就得到了一组合法的$x1,y1$的解：</p><p>$x1=y2,y1=x2-a/b\ast y2$</p><p>也就是我们递归下去即可。当$b=0$的时候我们就可以发现$x=1,y=0$是合法的</p><p>这是我们再返回$x=1,y=0$。最后就一直会回溯下去，得到我们的$x1,y1$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b)</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;y=temp-a/b*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是如果要求$ax+by=gcd(a,b)$的最小整数解的时候，我们就要对$x$批量的加上$b$的倍数，但是这不会影响最终的结果。</p><p>因为$ax+by+kab-kab=a(x+kb)+b*(y-ka)$，这样依旧是合法的。</p><p>因此我们直接让$x=(x$%$b+b)$%$b$即为最终的答案。</p><h2 id="3-逆元"><a href="#3-逆元" class="headerlink" title="$3.$逆元"></a>$3.$逆元</h2><p>对于$a$和$m$，如果$ax\equiv1(modm)$,那么称$x$是$a$在$m$下的逆元。</p><p>那么我们该怎么求解逆元呢？我们将逆元的等式转化一下:<br>$ax+my=1$</p><p>由于$ax+my=k$有解当且仅当$k$%$gcd(a,m)=0$的时候有解，说明$gcd(a,m)=1$</p><p>那么我们直接用扩展欧几里得求解即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b)</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;y=temp-a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span>&#123;<span class="comment">//a在m下的逆元</span></span><br><span class="line">    exgcd(a,m);</span><br><span class="line">    <span class="keyword">return</span> (x%m+m)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>逆元一般是用在除法取模上面，如$(a/b)$%$m$即为$a$%$m\ast inv(b,m)$</p><h2 id="4-埃拉托斯特尼筛法"><a href="#4-埃拉托斯特尼筛法" class="headerlink" title="$4.$埃拉托斯特尼筛法"></a>$4.$埃拉托斯特尼筛法</h2><p>埃拉托斯特尼筛法是一个复杂度为$nlnnlnn$的筛法。<br>当选中一个数为素数的时候，就把以这个数为因子的数全部筛掉即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pr;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N<span class="number">-10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">pr.push_back(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=N<span class="number">-10</span>;j+=i) vis[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-费马小定理"><a href="#5-费马小定理" class="headerlink" title="$5.$费马小定理"></a>$5.$费马小定理</h2><p>假设$a$是一个整数，$p$是一个质数，那么$a^p-a$是$p$的倍数</p><p>即$a^p\equiv a(modp)$,如果$a$不是$p$的倍数，这个定理也可以写成:</p><p>$a^{p-1}\equiv1(modp)$</p><h2 id="6-线性同余方程求解"><a href="#6-线性同余方程求解" class="headerlink" title="$6.$线性同余方程求解"></a>$6.$线性同余方程求解</h2><p>形如$ax\equiv b(modm)$即为线性同余方程。<br>将线性同余方程变形后即可得到：</p><p>$ax+my=b$<br>只有当$b$%$gcd(a,m)=0$时该方程才有解。<br>我们先利用扩展欧几里得算法求出</p><p>$ax+my=gcd(a,m)$的一组解$(x0,y0)$,那么$x=x0*(b/gcd(a,m))$%$m$<br>即为原方程的一组解。</p><h2 id="7-欧拉函数"><a href="#7-欧拉函数" class="headerlink" title="$7.$欧拉函数"></a>$7.$欧拉函数</h2><p>欧拉函数即为小于$n$的数中与$n$互质的数的个数<br>比如$\varphi(8)=4$<br>欧拉函数的通式为:</p><p>$\varphi(x)=x(1-\frac{1}{p1})(1-\frac{1}{p2})…(1-\frac{1}{pn})$</p><p>其中$p1,p2,…pn$为$x$的质因数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数论知识点总结&quot;&gt;&lt;a href=&quot;#数论知识点总结&quot; class=&quot;headerlink&quot; title=&quot;数论知识点总结&quot;&gt;&lt;/a&gt;数论知识点总结&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
